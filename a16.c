#include <stdio.h>
int main(){

// 전제적으로 이 코드에서 배열을 집합(set) 개념으로 빗대어 집합의 연산을 표현했으므로 주석에서 '집합'이라고 할 때 코드 상에서의 '배열'을 의미하는 것으로 이해하시면 되겠습니다.
  
// 집합 A, B 
int A[5]; 
int B[5];

// 합집합
//// A + B는 원소의 수가 5 ~ 10개 사이로 결정되므로 크기를 10로 설정
int Add[10]; 

// 차집합 (A에 대한 B의 차집합 = A - B)
// A - B는 원소의 수가 0~5개 사이로 결정되므로 크기를 5로 설정
int Sub[5];

// 교집합
// 차집합과 같은 이유로 배열 크기는 5
int Mul[5];

// 대칭차집합
// A 와 B 의 대칭차집합은 원소 수가 0~10 사이로 결정되므로 크기를 10으로 설정
int Sym[10];




///////////////////////////////////////////////////

  
// 사용자입력(두 집합 A 와 B 의 원소를 각각 5개 씩 입력, 단 각 배열의 배열값 초기값이 ‘0’ 이므로 자연수 전체집합의 부분집합으로서 정의하도록 한다.)
  
// A 집합 원소 입력
  
// for문으로 scanf를 5번 반복시켜 원소 5개 값을 입력받으며 순서대로 배열 A에 저장
int i;
printf("A 집합의 원소: ");
for (i = 0; i < 5; i++)
        scanf("%d", &A[i]);

// B 집합 원소 입력
printf("B 집합의 원소: ");
for (i = 0; i < 5; i++)
        scanf("%d", &B[i]);

// 사용자가 입력한 원소 값을 표시 및 확인
printf("집합 A: ");
for (i = 0; i < 5; i++)
        printf("%d ", A[i]);
printf("\n");

printf("집합 B: ");
for (i = 0; i < 5; i++)
        printf("%d ", B[i]);
printf("\n");

/////////////////////////////////////////////////

// 집합의 연산
  
// 합집합 연산
// 먼저 A 집합 원소를 모두 집합 Add에 저장
//  -> 배열의 index 값을 for문의 초기식, 조건식, 증감식에 변수로 이용하므로써 Add[0] = A[0]에서 Add[4] = A[4]까지의 명령을 할 수 있다.
for (i = 0; i < 5; i++) {
        Add[i] = A[i];
}

/* 
'A에 포함되지 않는 B의 원소 값'을 Add에 저장해야 한다.
그 값을 찾기 위해 A,B의 인덱스 값을 각각 for문의 조건식의 변수로 이용하여 두 for문을 중첩하므로써 {집합 B의 한 원소에 대해 집합 A의 원소를 각각(5개 모두) 비교한다} 를 5번 실행할 수 있다.
*/

int j;
int k = 5;
  
for (j = 0; j < 5; j++){ 
  for (i = 0; i < 5; i++){
                if (B[j] == A[i]) // 만약에 일치하면 그 값은 Add 에 입력할 필요가 없어 break
                   break;
                if (i == 4){ // 만약에 A[4]까지 비교하는 과정에서 값이 겹치지 않을 경우 이 조건을 만족시키면서 Add에 저장됨
                   Add[k] = B[j]; // Add[0] ~ Add[4] 는 line65에서 이미 값이 저장돼 있으므로 k 값은 5로 저장해 놓음(line70) 
                   k++;
                }
        }
}
  
// for문을 사용해 출력
printf("A 와 B 의 합집합: ");
for (i = 0;i < k; i++)
        printf("%d ", Add[i]);
printf("\n");

////////////////////////////////////////////////////
  
// 교집합 연산
// 중첩 for문을 이용해 집합 A와 집합 B의 원소 중 겹치는 값이 있는 경우를 if 문으로 판별한 다음 그 값을 Mul 에 저장
k = 0;
for (i = 0; i < 5; i++){
        for (j = 0; j < 5; j++){
                if (A[i] == B[j]){
                   Mul[k] = A[i];
                   k++;
                }
        }
}

// for문을 사용해 출력
printf("A 와 B 의 교집합: ");
for (i = 0; i < k; i++)
        printf("%d ", Mul[i]);
printf("\n");

/////////////////////////////////////////////////////////////////
  
// 차집합 연산
// 합집합 연산에서도 이용한 원리로 중첩 for문을 이용하여 원소 값이 같을 경우 break
k = 0;
for (i = 0; i < 5; i++){
        for (j = 0; j < 5; j++){
                if (A[i] == B[j])
                        break;
                if (j == 4){  // A의 원소의 값이 B의 모든 원소와 일치하지 않았을 때 그 값을 Sub에 저장
                        Sub[k] = A[i];
                        k++;
                }
        }
}

// for문을 사용해 출력
printf("A 에 대한 B 의 차집합: ");
for (i = 0; i < k; i++)
        printf("%d ", Sub[i]);
printf("\n");

////////////////////////////////////////////////////////////////
  
//대칭차집합 연산 (때때로 실행값이 오류가 나는 경우가 있는데 아직 해결하지는 못했습니다...)
/*
대칭차집합은 합집합에 대한 교집합으로 구할 수 있다.
합집합(Add) 와 교집합(Mul) 의 원소를 비교하기 위한 중첩 for문을 작성해야 한다.각 for문의 조건식에서 (변수 < 배열의 길이)를 써야 모든 원소가 서로 비교될 수 있다.
합집합과 교집합의 길이는 사용자입력에 따라 달라질 수 있으므로 sizeof함수를 이용해 Add 와 Mul의 길이를 알아낼 수 있다.
처음에 모든 배열을 정수형으로 정의하였기 때문에 배열원소 하나당 4byte 가 될 것이며, 이를 4로 나눈 값이 곧 배열의 길이가 된다.
*/
 
k = 0;
for (i = 0; i < sizeof(Add)/4; i++){
   for (j = 0; j < sizeof(Mul)/4; j++){
      if (Add[i] == Mul[j])
         break;
      if (j == (sizeof(Mul)/4 - 1)){ //line 79 와 마찬가지로 배열 index 값은 0부터 시작하므로 -1
                         Sym[k] = Add[i];
                         k++;
                  }
         }
  }
//for문을 이용해 출력
printf("A 와 B 의 대칭차집합: ");
for (i = 0; i < k; i++)
        printf("%d ", Sym[i]);
}



/* 이 프로그램은 집합의 연산에서 합집합, 교집합, 차집합, 대칭차집합을 계산하기 위해 작성한 것입니다. 
또한 정보 발표시간에 친구들에게 이 코드에 대해서 발표하기 위해 작성한 것이기도 합니다. 
집합과 배열의 개념이 비슷한 점을 이용해서 집합의 연산을 코드로 구현할 수 있을까 라는 궁금증을 해소할 수 있어서 좋은 개발이었습니다.
*/
